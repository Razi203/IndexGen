#include <iostream>
#include <cassert>
#include <iomanip>
#include <chrono>
#include <fstream>
#include <random>
#include <thread>
#include <unordered_set>
#include <unordered_map>
#include <map>
#include "Utils.hpp"
#include "IndexGen.hpp"
#include "LinearCodes.hpp"
#include "Candidates.hpp"
#include "MaxClique.hpp"
#include "SparseMat.hpp"
#include "Decode.hpp"
using namespace std;

/*	*** Codebook Generator Usage ***
 * 	GenerateCodebookAdj(params): Generates a set of codewords of length codeLen, s.t. the minimal edit distance between
 * 	any two codewords is at least codeMinED. See algorithm details in the file - Index Generator Project.docx.
 * 	parameters:
 * 	params.codeLen: Length of code words (int)
 * 	params.candMinHD: Minimal Hamming distance between any two candidates. From {1,2,3,4,5} (int)
 * 	params.codeMinED: Minimal edit distance between any two code words. From {3,4,5} (int)
 * 	params.maxRun: Longest allowed homopolymer. For no restriction on homopolymers set maxRun=0 (int)
 * 	params.minGCCont: Minimal GC content. For no restriction on GC content set minGCCont=0 (double)
 * 	params.maxGCCont: Maximal GC content. For no restriction on GC content set minGCCont=0 (double)
 * 	params.threadNum: Number of threads on system (int)
 * 	params.saveInterval: Interval between two save points in seconds (int)

 * 	*** Decode (find closest codeword) Usage ***
 * 	Decode(codebook, receivedWords, decodedWords, codeLen, threadNum): For every received word in receivedWords, finds
 * 	the codeword s.t. ED(received word, codeword) is minimal
 * 	codebook: A codebook generated by GenerateCodebookAdj (vector<string>)
 * 	receivedWords: A set of codewords passed through some error channel (vector<string>)
 *	decodedWords: For each received word the closest codeword. (vector<string>)
 *	codeLen: Length of codewords (int)
 *	threadNum: Number of threads on system (int)
 */

// hereinafter 0=A, 1=C, 2=G, 3=T
//	Params: maxRun = {0, 3, 4} , minGCCont = 0.3, maxGCCont = 0.7 or minGCCont=maxGCCont=0
int main() {

	clock_t begin = clock();

//	unsigned sd = chrono::high_resolution_clock::now().time_since_epoch().count();

	int codeLen = 10;
	int minHD = 4;
	int minED = 4;
	int maxRun = 3;
	double minGCCont = 0.3;
	double maxGCCont = 0.7;
	int threadNum = 8;
	int saveInterval = 80000;
	Params params(codeLen, minHD, minED, maxRun, minGCCont, maxGCCont, threadNum, saveInterval);

//	GenerateCodebookAdjResumeFromFile();
	for (int codeLen = 10; codeLen <= 16; codeLen++) {
		params.codeLen = codeLen;
		GenerateCodebookAdj(params);
	}

	clock_t end = clock();
	double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
	cout << "Total Time: " << fixed << setprecision(2) << elapsed_secs << "\tseconds" << endl;
}
