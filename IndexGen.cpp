/**
 * @file IndexGen.cpp
 * @brief The main entry point for the DNA codebook generator application.
 *
 * This file contains the `main` function that drives the entire process. It sets up
 * the configuration parameters, initiates the codebook generation, and measures
 * the total execution time.
 */

#include <iostream>
#include <iomanip>
#include <chrono>

#include "IndexGen.hpp" // Use the new documented header
#include "Candidates.hpp"
#include "SparseMat.hpp"
#include "Decode.hpp"

using namespace std;

// The alphabet mapping used throughout the project:
// 0 = A (Adenine)
// 1 = C (Cytosine)
// 2 = G (Guanine)
// 3 = T (Thymine)

/*	*** Codebook Generator Usage ***
 * 	GenerateCodebookAdj(params): Generates a set of codewords of length codeLen, s.t. the minimal edit distance between
 * 	any two codewords is at least codeMinED. See algorithm details in the file - Index Generator Project.docx.
 *
 * 	parameter details are in the Params struct (IndexGen.hpp)

 * 	*** Decode (find closest codeword) Usage ***
 * 	Decode(codebook, receivedWords, decodedWords, codeLen, threadNum): For every received word in receivedWords, finds
 * 	the codeword s.t. ED(received word, codeword) is minimal
 * 	codebook: A codebook generated by GenerateCodebookAdj (vector<string>)
 * 	receivedWords: A set of codewords passed through some error channel (vector<string>)
 *	decodedWords: For each received word the closest codeword. (vector<string>)
 *	codeLen: Length of codewords (int)
 *	threadNum: Number of threads on system (int)
 */

/**
 * @brief The main function and entry point of the program.
 */
int main()
{
	using std::cout;
	using std::endl;
	using std::fixed;
	using std::setprecision;

	// Start the master timer to measure total execution time.
	auto start = std::chrono::steady_clock::now();

	// --- Configuration ---

	// 1. Set the common parameters for the codebook generation.
	int codeLen = 10;
	int minED = 4;
	int maxRun = 3;
	double minGCCont = 0.3;
	double maxGCCont = 0.7;
	int threadNum = 32;
	int saveInterval = 80000;

	// 2. Choose the generation method and create its specific constraints.
	// To switch methods, just uncomment the block you want to use.

	/*
	// --- Option A: Use the Linear Code method (This matches your original setup) ---
	int minHD = 4; // This is the specific parameter for the Linear Code method
	auto constraints = std::make_unique<LinearCodeConstraints>(minHD);
	Params params(codeLen, minED, maxRun, minGCCont, maxGCCont, threadNum, saveInterval,
				  GenerationMethod::LINEAR_CODE, std::move(constraints));
	*/

	// /*
	// --- Option B: Use the VT Code method (Example) ---
	int remainder = 0; // The specific parameter for the VT Code method
	auto constraints = std::make_unique<VTCodeConstraints>(remainder);
	Params params(codeLen, minED, maxRun, minGCCont, maxGCCont, threadNum, saveInterval,
				  GenerationMethod::VT_CODE, std::move(constraints));
	// */

	/*
	// --- Option C: Use the All Strings method (Example) ---
	// This method has no specific parameters, so we just create the empty object.
	auto constraints = std::make_unique<AllStringsConstraints>();
	Params params(codeLen, minED, maxRun, minGCCont, maxGCCont, threadNum, saveInterval,
				  GenerationMethod::ALL_STRINGS, std::move(constraints));
	*/

	// --- Execution ---
	// The rest of your main function remains the same!
	// The `GenerateCodebookAdj` function now internally knows which algorithm to run.

	// Option 1: Start a new codebook generation process.
	for (int len = 10; len <= 14; len++)
	{
		cout << "--- Starting Generation for Codeword Length " << len << " ---" << endl;
		params.codeLen = len;
		GenerateCodebookAdj(params);
		cout << "--- Finished Generation for Codeword Length " << len << " ---" << endl
			 << endl;
	}

	// Option 2: Resume a previously interrupted generation process.
	// Note: This function would also need to be updated to use your new FileToParams function.
	GenerateCodebookAdjResumeFromFile();

	// --- Completion ---
	auto end = std::chrono::steady_clock::now();
	std::chrono::duration<double> elapsed_secs = end - start;
	cout << "Total Execution Time: " << fixed << setprecision(2) << elapsed_secs.count() << " seconds" << endl;

	return 0; // Indicate successful execution
}