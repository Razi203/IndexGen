/**
 * @file IndexGen.cpp
 * @brief The main entry point for the DNA codebook generator application.
 *
 * This file contains the `main` function that drives the entire process. It sets up
 * the configuration parameters, initiates the codebook generation, and measures
 * the total execution time.
 */

#include <iostream>
#include <iomanip>
#include <chrono>

#include "IndexGen.hpp" // Use the new documented header
#include "Candidates.hpp"
#include "SparseMat.hpp"
#include "Decode.hpp"

using namespace std;

// The alphabet mapping used throughout the project:
// 0 = A (Adenine)
// 1 = C (Cytosine)
// 2 = G (Guanine)
// 3 = T (Thymine)

/*	*** Codebook Generator Usage ***
 * 	GenerateCodebookAdj(params): Generates a set of codewords of length codeLen, s.t. the minimal edit distance between
 * 	any two codewords is at least codeMinED. See algorithm details in the file - Index Generator Project.docx.
 * 	parameters:
 * 	params.codeLen: Length of code words (int)
 * 	params.candMinHD: Minimal Hamming distance between any two candidates. From {1,2,3,4,5} (int)
 * 	params.codeMinED: Minimal edit distance between any two code words. From {3,4,5} (int)
 * 	params.maxRun: Longest allowed homopolymer. For no restriction on homopolymers set maxRun=0 (int)
 * 	params.minGCCont: Minimal GC content. For no restriction on GC content set minGCCont=0 (double)
 * 	params.maxGCCont: Maximal GC content. For no restriction on GC content set minGCCont=0 (double)
 * 	params.threadNum: Number of threads on system (int)
 * 	params.saveInterval: Interval between two save points in seconds (int)

 * 	*** Decode (find closest codeword) Usage ***
 * 	Decode(codebook, receivedWords, decodedWords, codeLen, threadNum): For every received word in receivedWords, finds
 * 	the codeword s.t. ED(received word, codeword) is minimal
 * 	codebook: A codebook generated by GenerateCodebookAdj (vector<string>)
 * 	receivedWords: A set of codewords passed through some error channel (vector<string>)
 *	decodedWords: For each received word the closest codeword. (vector<string>)
 *	codeLen: Length of codewords (int)
 *	threadNum: Number of threads on system (int)
 */

/**
 * @brief The main function and entry point of the program.
 */
int main()
{

	// Start the master timer to measure total execution time.
	auto start = std::chrono::steady_clock::now();

	// --- Configuration ---
	// Set all the parameters for the codebook generation.
	int codeLen = 10;		  // The length of each DNA sequence in the codebook.
	int minHD = 4;			  // Use a linear code to generate candidates with min Hamming distance of 4.
	int minED = 4;			  // The target minimum edit distance for the final codebook.
	int maxRun = 3;			  // Allow homopolymer runs of up to 3 (e.g., 'AAA'), but not 4.
	double minGCCont = 0.3;	  // Minimum GC-content of 30%.
	double maxGCCont = 0.7;	  // Maximum GC-content of 70%.
	int threadNum = 8;		  // Use 8 threads for parallel processing.
	int saveInterval = 80000; // Save progress to allow for recovery.

	Params params(codeLen, minHD, minED, maxRun, minGCCont, maxGCCont, threadNum, saveInterval);

	// --- Execution ---

	// Option 1: Start a new codebook generation process.
	// This example demonstrates looping to generate codebooks of increasing length.
	for (int len = 10; len <= 14; len++)
	{
		cout << "--- Starting Generation for Codeword Length " << len << " ---" << endl;
		params.codeLen = len;
		GenerateCodebookAdj(params); // This is the main call to the generation algorithm.
		cout << "--- Finished Generation for Codeword Length " << len << " ---" << endl
			 << endl;
	}

	// Option 2: Resume a previously interrupted generation process.
	// Uncomment the following line to resume from saved progress files.
	// GenerateCodebookAdjResumeFromFile();

	// --- Completion ---
	auto end = std::chrono::steady_clock::now();
	std::chrono::duration<double> elapsed_secs = end - start;
	cout << "Total Execution Time: " << fixed << setprecision(2) << elapsed_secs.count() << " seconds" << endl;

	return 0; // Indicate successful execution
}
